import os
import sys
import nbformat
import subprocess
from nbconvert.preprocessors import ExecutePreprocessor

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from constants import BEST_MODELS_DIRECTORY, ENSEMBLE_PYTHON_FILE_PATH

class RunAllEnsembleModels:
    def __init__(self):
        
        """
        Initializes an instance of the class by setting up file paths.

        Attributes:
            directory_path (str): Absolute path to the directory containing pre selected best models.
            ensemble_notebook_path (str): Absolute path to the python file that run ensemble models.
            
        Raises:
            FileNotFoundError: If the specified file paths cannot be found.
        """
        
        try:
            # Get the current script's directory
            self.script_directory = os.path.dirname(os.path.abspath(__file__))

            # Define the relative paths
            relative_paths = {
                'directory_path': os.path.join("../", BEST_MODELS_DIRECTORY),
                'ensemble_code_file_path': os.path.join("../", ENSEMBLE_PYTHON_FILE_PATH),  
            }

            # Get the absolute paths
            self.directory_path = os.path.abspath(os.path.join(self.script_directory, relative_paths['directory_path']))
            self.ensemble_code_file_path = os.path.abspath(os.path.join(self.script_directory, relative_paths['ensemble_code_file_path']))

        except FileNotFoundError:
            raise FileNotFoundError(f"File not found")
            
    def run_python_file(self, file_path, file_dir=None):
        """
        Execute a Python file (.py) and capture its output.

        Args:
        - file_path (str): Path to the .py file to execute.
        - file_dir (str, optional): Directory path where the Python file should be executed.
                                    Defaults to None.

        Returns:
        - list: List of outputs (stdout or stderr) generated by the Python file.
        """
        if file_dir is None:
            file_dir = os.path.dirname(file_path)

        # Check if the Python file exists
        if not os.path.isfile(file_path):
            print(f'Error: Python file not found at {file_path}')
            return None

        try:
            # Change the working directory if provided
            cwd = os.getcwd()
            if file_dir:
                os.chdir(file_dir)

            # Execute the Python file and capture stdout and stderr
            result = subprocess.run(
                ['python', file_path], 
                capture_output=True, 
                text=True
            )

            # Change back to the original working directory
            os.chdir(cwd)

            # Capture output and errors
            stdout_output = result.stdout.strip()
            stderr_output = result.stderr.strip()

            outputs = []
            if stdout_output:
                outputs.append(stdout_output)
            if stderr_output:
                outputs.append(f"Error: {stderr_output}")

            return outputs

        except Exception as e:
            print(f'Error executing the Python file {file_path}: {e}')
            return None
        
        
    def run_notebook(self, notebook_path, notebook_dir=None):
        """
        Execute a Jupyter notebook (.ipynb file) and capture its output.

        Args:
        - notebook_path (str): Path to the .ipynb file to execute.
        - notebook_dir (str, optional): Directory path where the notebook should be executed.
                                        Defaults to None.

        Returns:
        - list: List of outputs generated by the notebook.
        """
        if notebook_dir is None:
            notebook_dir = os.path.dirname(notebook_path)

        try:
            with open(notebook_path) as f:
                nb = nbformat.read(f, as_version=4)
        except FileNotFoundError:
            print(f'Error: Notebook file not found at {notebook_path}')
            return None
        except Exception as e:
            print(f'Error reading the notebook {notebook_path}: {e}')
            return None
        
        ep = ExecutePreprocessor(timeout=600, kernel_name='python3')
        try:
            # Execute the notebook
            ep.preprocess(nb, {'metadata': {'path': notebook_dir}})
        except Exception as e:
            print(f'Error executing the notebook {notebook_path}: {e}')
            return None
        
        # Save the executed notebook back to file
        try:
            with open(notebook_path, 'w') as f:
                nbformat.write(nb, f)
        except Exception as e:
            print(f'Error saving executed notebook {notebook_path}: {e}')
        
        # Collecting the output of the notebook
        output_cells = [cell for cell in nb.cells if cell.cell_type == 'code']
        outputs = []
        for cell in output_cells:
            for output in cell.get('outputs', []):
                if output.output_type == 'stream':
                    outputs.append(output.text.strip())
                elif output.output_type == 'execute_result':
                    outputs.append(output['data']['text/plain'].strip())
                elif output.output_type == 'error':
                    outputs.append(f"Error: {output['evalue']}")
        
        return outputs
    
    # Function to find notebook paths in a directory
    def find_files(self, directory, extension = '.py'):
        
        """
        Finds and returns a list of file paths in the specified directory that have a given file extension.

        Args:
            directory (str): The path to the directory where the search for files will be performed.
            extension (str, optional): The file extension to look for (default is '.py'). 
                                    Can be used to filter for specific file types such as '.ipynb' or '.py'.

        Returns:
            list: A list of file paths with the specified extension found in the directory.
                Each file path is returned as an absolute path.
        """
    
        return [os.path.join(directory, file) for file in os.listdir(directory) if file.endswith(extension)]

    def print_outputs(self, output, search_val):
        
        """
        Prints lines from the output that contain a specified search value. 
        This method was used to find the most important results form the output.

        Args:
            output (list): A list of strings representing the output to search through.
            search_val (str): The value or substring to search for within each line of the output.

        Returns:
            None: This function prints matching lines to the console.
        """
    
        for line in output:
            if search_val in line: 
                print(f'{line}')

    def initialize(self):
        
        """
        Initializes the execution process by running Python files in a specified directory, followed by an ensemble Python file. 
        It executes each model, captures and prints results, then run the ensemble model using that model's predictions and print its outputs

        Workflow:
        1. Retrieves a list of Python files in the specified directory.
        2. Runs each Python file and captures output (models).
        3. Searches the output for specific values and prints matching lines (e.g., 'R2', 'treatment'). (Focuses on simplifying 
        output presentation to make it easier to analyze)
        4. Executes a specified ensemble Python file and prints results for 'Accuracy' and 'treatment'.
        
        Args:
            None
        
        Returns:
            None: This function prints selected outputs to the console.
        """
        
        # Get file paths in dir1. Use .ipynb instead of .py if you want to run notebooks
        file_list = self.find_files(self.directory_path, '.py')
        
        # Execute the file in dir1 and then ensemble.py file
        for notebook_path in file_list:
            print(f'Running {notebook_path} \n')
            # Uncomment below line if you want to run notebooks
            #output1 = self.run_notebook(notebook_path, self.directory_path)
            output1 = self.run_python_file(notebook_path, self.directory_path)
            
            # Print selected outputs. If you want full output then comment these 2 lines and print output1
            self.print_outputs(output1, 'R2')
            self.print_outputs(output1, 'treatment')

            # Execute the ensemble_notebook 
            print(f'\nRunning {self.ensemble_code_file_path} \n')
            output2 = self.run_python_file(self.ensemble_code_file_path)
            # Print selected outputs. If you want full output then comment these 2 lines and print output2
            self.print_outputs(output2, 'Accuracy')
            self.print_outputs(output2, 'treatment')
            print('--------------------------------------------------------- \n\n')

if __name__ == "__main__":
    models = RunAllEnsembleModels()
    # Call the initialize method to execute the workflow
    models.initialize()